## Problema

12 - O teu jogo é _shooter_ de sucesso, e a classe base de todas as armas é
`Weapon`, cuja interface está definida da seguinte forma:

```cs
interface IWeapon
{
    // This property is true if weapon is in alternate firing mode, false
    // otherwise
    bool IsAlternate { get; }

    // Reload the weapon
    void Reload();

    // Shoot the weapon, return true if any rounds left to shoot in current
    // firing mode, false otherwise
    bool Shoot();

    // Switch between main and alternate firing modes
    void SwitchFireMode();
}
```

Os teus investidores exigem um DLC que inclua _melee weapons_, ou seja, armas
para combate corpo a corpo. Os investidores tomaram a liberdade de adquirir um
pacote de _assets_ para esse fim, e querem integra-lo no jogo. A interface das
_melee weapons_ é a seguinte:

```cs
interface IMelee
{
    // Attacks return true if they hit opponent
    bool AttackFromAbove();
    bool AttackFromBelow();
    bool AttackFromTheLeft();
    bool AttackFromTheRight();
}
```

Como podes resolver este problema? Escreve código para esse fim e justifica as
tuas opções.

**Nota:** Será oferecida uma chave Steam para quem apresentar a primeira solução
correta deste problema.

## Soluções 

### Soluções 1

De forma a seguir princípios *SOLID* (especificamente o *Open/Closed principle*)
, não devemos modificar a classe `Weapon` visto que esta já funciona 
perfeitamente, sem bugs. Ao invés disto, iremos criar uma nova
classe `Melee` que herda de `Weapon` (visto que as *melee weapons* também serão
`Weapons`, e muito provavelmente temos várias componentes na classe base que
`Melee` terá de utilizar para ser uma 'arma'), e que implementa a interface
`IMelee`.

Porém, enquanto `Melee` é um `Weapon`, ele não poderá utilizar os seus métodos
e propriedades (ao menos os definidos na interface, que são os que conhecemos),
visto que uma arma *melee* não têm modos de tiro, possibilidade de dar
*reload*, nem a possibilidade de atirar (componentes `IsAlternate` /
`SwitchFireMode()`, `Reload()`, e `Shoot()`, respetivamente). Para fazermos com
que a classe `Melee` não consiga aceder a estes métodos, então, precisamos os
'esconder', que é feito com a *keyword* `new`, como demonstrado neste código:

```cs
private class Melee : Weapon, IMelee
{
    // Always returns false
    bool new IsAlternate { get; }

    void new Reload()
    {
        // Code here (returns an exception or does nothing)
    }

    bool new Shoot()
    {
        // Code here (returns an exception or does nothing)
    }

    void new SwitchFireMode()
    {
        // Code here (returns an exception or does nothing)
    }

    // Insert other components from Weapon class that cannot be used here with
    // the 'new' keyword

    public Melee()
    {

    }

    // Implement IMelee methods
    bool AttackFromAbove()
    {

    }

    bool AttackFromBelow()
    {

    }

    bool AttackFromTheLeft()
    {

    }

    bool AttackFromTheRight()
    {

    }
}
```

Após isto e o resto do código ser feito, então, os desenvolvedores podem 
integrar armas `Melee` nesta classe, sem precisarem de preocupações em relação a
funcionalidade as outras armas já dentro do jogo.

*Por [Marco Domingos](https://github.com/condmaker)*